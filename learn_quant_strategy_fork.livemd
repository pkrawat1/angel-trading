# Learn Quant Strategy

```elixir
Mix.install(
  [
    {:req, "~> 0.4.5"},
    {:explorer, "~> 0.7.1"},
    {:kino_explorer, "~> 0.1.12"},
    {:nx, "~> 0.6.4"},
    {:kino_vega_lite, "~> 0.1.10"},
    {:kino_bumblebee, "~> 0.4.0"},
    {:exla, ">= 0.0.0"}
  ],
  config: [nx: [default_backend: EXLA.Backend]]
)
```

## Nifty 200 CSV

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
resp = Req.get!("https://nsearchives.nseindia.com/content/indices/ind_nifty200list.csv")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
ticker = "IRB.NS"
range = "1y"
interval = "1d"
metrics = "close"

url =
  "https://query1.finance.yahoo.com/v8/finance/chart/#{ticker}?metrics=#{metrics}&interval=#{interval}&range=#{range}"

IO.puts(url)
resp = Req.get!(url)

require Explorer.DataFrame, as: DF
require Explorer.Series, as: S

quote_data =
  resp.body["chart"]["result"]
  |> List.first()
  |> get_in(["indicators", "quote"])
  |> List.first()
  |> DF.new()
  |> DF.mutate_with(
    &[
      price_change:
        S.subtract(
          &1["close"],
          S.shift(&1["close"], 1)
          |> S.fill_missing(:mean)
        )
    ]
  )

timestamp_data =
  resp.body["chart"]["result"]
  |> List.first()
  |> Map.take(["timestamp"])
  |> DF.new()

data = DF.concat_columns([timestamp_data, quote_data])
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# Assuming you have already loaded the data into the 'data' DataFrame

# Calculate daily price changes
price_change = DF.select(data, "price_change")

# Calculate gains and losses
gains = DF.filter_with(price_change, &S.greater(&1["price_change"], 0))

losses =
  DF.filter_with(price_change, &S.less(&1["price_change"], 0))
  |> DF.mutate_with(&[price_change: S.abs(&1["price_change"])])

# Calculate average gains and losses over a specified period (e.g., 14 days)
average_gains = S.window_mean(gains["price_change"], 14)
average_losses = S.window_mean(losses["price_change"], 14)

min_size = min(S.size(average_gains), S.size(average_losses))

# Calculate relative strength (RS)
rs = S.divide(S.tail(average_gains, min_size), S.tail(average_losses, min_size))

# Calculate the Relative Strength Index (RSI)
rsi = S.tail(S.subtract(100, S.divide(100, S.add(1, rs))), 1)

# Add the RSI column to the original DataFrame
# data_with_rsi = DF.concat_columns(data, rsi)

# Display the DataFrame with RSI
# DF.show(data_with_rsi)
```

<!-- livebook:{"attrs":"eyJjb21waWxlciI6ImV4bGEiLCJudW1faW1hZ2VzX3Blcl9wcm9tcHQiOjIsIm51bV9zdGVwcyI6MjAsInNlZWQiOm51bGwsInNlcXVlbmNlX2xlbmd0aCI6NTAsInRhc2tfaWQiOiJ0ZXh0X3RvX2ltYWdlIiwidmFyaWFudF9pZCI6InN0YWJsZV9kaWZmdXNpb25fdjFfNCJ9","chunks":[[0,1104],[1106,553]],"kind":"Elixir.KinoBumblebee.TaskCell","livebook_object":"smart_cell"} -->

```elixir
repository_id = "CompVis/stable-diffusion-v1-4"
{:ok, tokenizer} = Bumblebee.load_tokenizer({:hf, "openai/clip-vit-large-patch14"})
{:ok, clip} = Bumblebee.load_model({:hf, repository_id, subdir: "text_encoder"})

{:ok, unet} =
  Bumblebee.load_model({:hf, repository_id, subdir: "unet"},
    params_filename: "diffusion_pytorch_model.bin"
  )

{:ok, vae} =
  Bumblebee.load_model({:hf, repository_id, subdir: "vae"},
    architecture: :decoder,
    params_filename: "diffusion_pytorch_model.bin"
  )

{:ok, scheduler} = Bumblebee.load_scheduler({:hf, repository_id, subdir: "scheduler"})

{:ok, featurizer} =
  Bumblebee.load_featurizer({:hf, repository_id, subdir: "feature_extractor"})

{:ok, safety_checker} =
  Bumblebee.load_model({:hf, repository_id, subdir: "safety_checker"})

serving =
  Bumblebee.Diffusion.StableDiffusion.text_to_image(clip, unet, vae, tokenizer, scheduler,
    num_steps: 20,
    num_images_per_prompt: 2,
    safety_checker: safety_checker,
    safety_checker_featurizer: featurizer,
    compile: [batch_size: 1, sequence_length: 50],
    defn_options: [compiler: EXLA]
  )

text_input =
  Kino.Input.textarea("Text",
    default: "numbat, forest, high quality, detailed, digital art"
  )

form = Kino.Control.form([text: text_input], submit: "Run")
frame = Kino.Frame.new()

Kino.listen(form, fn %{data: %{text: text}} ->
  Kino.Frame.render(frame, Kino.Text.new("Running..."))
  output = Nx.Serving.run(serving, text)

  for result <- output.results do
    Kino.Image.new(result.image)
  end
  |> Kino.Layout.grid(columns: 2)
  |> then(&Kino.Frame.render(frame, &1))
end)

Kino.Layout.grid([form, frame], boxed: true, gap: 16)
```
